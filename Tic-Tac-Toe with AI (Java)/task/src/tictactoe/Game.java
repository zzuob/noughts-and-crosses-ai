package tictactoe;

import java.util.*;

import tictactoe.Menu.Player;

/**
 * Represents a game of tic-tac-toe, including player AI's and the game board.
 */
public class Game {

    /**
     * Used to make random moves.
     */
    private static final Random random = new Random();
    /**
     * Represents the game board.
     */
    private final Grid grid;
    /**
     * Collection of move generation strategies offered in the {@link Menu}.
     */
    @SuppressWarnings("MismatchedQueryAndUpdateOfCollection")
    private final Map<Menu.Player, Strategy> moveStrategy;

    /**
     * Create a new game with an empty board and populate the move strategies.
     */
    public Game() {
        this.grid = new Grid();
        this.moveStrategy = new HashMap<>() {
            {
                put(Player.USER, new UserMove(grid));
                put(Player.EASY, new EasyMove(grid));
                put(Player.MEDIUM, new MediumMove(grid));
                put(Player.HARD, new HardMove(grid));
            }
        };
        if (moveStrategy.size() != Player.values().length) {
            throw new NoSuchElementException("Not all required player types have been implemented");
        }
    }

    /**
     * Get a random element from a list.
     * @return element, {@link Optional#empty()} if list is empty
     */
    private static <E> Optional<E> chooseRandomElement(List<E> list) {
        if (!list.isEmpty()) {
            return Optional.of(list.get(random.nextInt(list.size())));
        }
        return Optional.empty();
    }

    /**
     * A move generated by a user's input.
     */
    public class UserMove extends Strategy {

        /**
         * Set the Strategy's name and grid to apply the move to.
         */
        public UserMove(Grid grid) {
            super("user", grid);
        }

        /**
         * Replies for invalid user input.
         */
        private enum Reply {
            NOT_FREE("This cell is occupied! Choose another one!"),
            NOT_INT("You should enter numbers!"),
            OUT_OF_RANGE("Coordinates should be from 1 to 3!");

            private final String msg;

            Reply(String string) {
                this.msg = string;
            }

            @Override
            public String toString() {
                return this.msg;
            }
        }


        /**
         * Loop until user inputs a valid move position.
         * @return position of unoccupied cell
         */
        @Override
        int[] execute(Piece toPlace) {
            while (true) {
                Scanner scan = new Scanner(System.in);
                System.out.print("Enter the coordinates: ");
                if (scan.hasNextLine()) {
                    String[] indexes = scan.nextLine().trim().split("\\s");
                    // validate input
                    if (indexes.length != 2) {
                        System.out.println(Reply.NOT_INT);
                        continue;
                    }
                    try {
                        int y = Integer.parseInt(indexes[0]) - 1;
                        int x = Integer.parseInt(indexes[1]) - 1;
                        Cell cell = grid.getCell(y, x);
                        if (cell.isEmpty()) { // check cell is unoccupied
                            return new int[]{y, x};
                        }
                        System.out.println(Reply.NOT_FREE);
                    } catch (NumberFormatException e) {
                        System.out.println(Reply.NOT_INT);
                    } catch (ArrayIndexOutOfBoundsException e){
                        System.out.println(Reply.OUT_OF_RANGE);
                    }
                }
            }
        }
    }

    /**
     * A randomly generated move.
     */
    public class EasyMove extends Strategy {

        /**
         * Set the Strategy's name and grid to apply the move to.
         */
        public EasyMove(Grid grid) {
            super("easy", grid);
        }

        /**
         * Choose a random empty position on the game board.
         * @return position of unoccupied cell
         */
        private static int[] makeRandomMove(Grid grid) {
            Optional<int[]> freeCell = chooseRandomElement(grid.getEmptyCells());
            if (freeCell.isPresent()) {
                return freeCell.get();
            }
            throw new NoSuchElementException("Cannot make a move, there are no empty cells");
        }

        /**
         * Create a random move.
         * @return position of random unoccupied cell
         */
        @Override
        int[] execute(Piece toPlace) {
            printPlayerType();
            return makeRandomMove(grid);
        }
    }

    /**
     * A look-ahead 1 move.
     */
    public class MediumMove extends Strategy {

        /**
         * Set the Strategy's name and grid to apply the move to.
         */
        public MediumMove(Grid grid) {
            super("medium", grid);
        }

        /**
         * Create a move to win the game for a piece or block the opponent from winning.
         * Otherwise, create a random move.
         * @return position to place piece at
         */
        @Override
        int[] execute(Piece toPlace) {
            printPlayerType();
            Map<Character, List<int[]>> winMoves = grid.getWinMoves();
            Optional<int[]> move = chooseRandomElement(winMoves.get(toPlace.getSymbol()));
            if (move.isPresent()) {
                return move.get(); // make any moves to win the game
            }
            move = chooseRandomElement(winMoves.get(toPlace.getOpposite().getSymbol()));
            // make any moves to stop opponent from winning
            return move.orElseGet(() -> EasyMove.makeRandomMove(grid)); // otherwise choose randomly
        }
    }

    /**
     * The optimal move for the current player.
     */
    public class HardMove extends Strategy {

        /**
         * Set the Strategy's name and grid to apply the move to.
         */
        public HardMove(Grid grid) {
            super("hard", grid);
        }

        /**
         * Utilise the minimax algorithm to find the best possible move for the current player.
         * @return position to place piece at
         */
        @Override
        int[] execute(Piece toPlace) {
            printPlayerType();
            Minimax minimax = new Minimax(grid);
            return minimax.getBestMove();
        }
    }

    /**
     * Play a game of tic-tac-toe
     * @param playerX user/ai strategy to control X
     * @param playerO user/ai strategy to control O
     */
    public void play(Player playerX, Player playerO) {
        System.out.println(grid);
        grid.evaluateState();
        while (grid.getState() == Grid.State.UNFINISHED) {
            Player current;
            Piece nextPiece;
            if (grid.isXTurn()) {
                current = playerX;
                nextPiece = Grid.X_PIECE;
            } else {
                current = playerO;
                nextPiece = Grid.O_PIECE;
            }
            int[] position = moveStrategy.get(current).execute(nextPiece); // find move location
            grid.setCell(position[0], position[1], nextPiece); // apply move
            System.out.println(grid);
        }
        System.out.println(grid.getState());
    }
}
